import { Injectable, Logger } from '@nestjs/common';
import { OpenAI } from 'openai';
import { retry } from 'retry';
import { Cache } from 'cache-manager';
import { IActivity } from '../interfaces/activity.interface';
import { DEFAULT_POINTS_CONFIG } from '../constants/points.constants';

/**
 * Service responsible for detecting AI-generated code in Azure DevOps activities
 * Version: 1.0.0
 */
@Injectable()
export class AiDetectionService {
    private readonly confidenceThreshold = 0.8;
    private readonly cacheKeyPrefix = 'ai_detection:';
    private readonly cacheTTL = 24 * 60 * 60; // 24 hours
    private readonly patternWeights = {
        standardPatterns: 0.4,
        heuristicAnalysis: 0.3,
        openAiAnalysis: 0.3
    };

    constructor(
        private readonly openai: OpenAI,
        private readonly cache: Cache,
        private readonly logger: Logger
    ) {
        this.logger.setContext('AiDetectionService');
    }

    /**
     * Detects if an activity contains AI-generated code using multiple detection methods
     * @param activity The activity to analyze
     * @returns Promise<boolean> indicating if the activity contains AI-generated code
     */
    async detectAiGenerated(activity: IActivity): Promise<boolean> {
        try {
            // Check cache first
            const cacheKey = `${this.cacheKeyPrefix}${activity.id}`;
            const cachedResult = await this.cache.get<boolean>(cacheKey);
            
            if (cachedResult !== undefined) {
                this.logger.debug(`Cache hit for activity ${activity.id}`);
                return cachedResult;
            }

            const codeContent = this.extractCodeContent(activity);
            if (!codeContent) {
                return false;
            }

            // Parallel execution of detection methods
            const [patternScore, heuristicScore, openAiScore] = await Promise.all([
                this.detectStandardPatterns(codeContent),
                this.performHeuristicAnalysis(codeContent),
                this.performOpenAiAnalysis(codeContent)
            ]);

            // Calculate weighted confidence score
            const confidenceScore = 
                (patternScore * this.patternWeights.standardPatterns) +
                (heuristicScore * this.patternWeights.heuristicAnalysis) +
                (openAiScore * this.patternWeights.openAiAnalysis);

            const isAiGenerated = confidenceScore >= this.confidenceThreshold;

            // Update activity metadata
            activity.metadata.aiConfidence = confidenceScore;
            activity.isAiGenerated = isAiGenerated;

            // Cache the result
            await this.cache.set(cacheKey, isAiGenerated, this.cacheTTL);

            this.logger.debug(`AI detection completed for activity ${activity.id} with confidence ${confidenceScore}`);
            return isAiGenerated;

        } catch (error) {
            this.logger.error(`Error in AI detection for activity ${activity.id}: ${error.message}`);
            // Fallback to pattern-based detection only
            return this.fallbackDetection(activity);
        }
    }

    /**
     * Extracts code content from activity metadata
     */
    private extractCodeContent(activity: IActivity): string | null {
        try {
            const { description, title } = activity.metadata;
            return description || title || null;
        } catch (error) {
            this.logger.error(`Error extracting code content: ${error.message}`);
            return null;
        }
    }

    /**
     * Detects common patterns associated with AI-generated code
     */
    private async detectStandardPatterns(content: string): Promise<number> {
        const patterns = [
            /\/\/ Generated by|@generated|This code was generated/i,
            /TODO: Implement|FIXME: Implement/i,
            /function\s+\w+\s*\([^)]*\)\s*{\s*return\s+[^;]+;\s*}/,
            /console\.log\(['"]Debug:/
        ];

        const matches = patterns.filter(pattern => pattern.test(content));
        return matches.length / patterns.length;
    }

    /**
     * Performs heuristic analysis of code structure and patterns
     */
    private async performHeuristicAnalysis(content: string): Promise<number> {
        let score = 0;
        
        // Check for consistent formatting
        if (/^[ ]{2,4}[^ ]/gm.test(content)) score += 0.2;
        
        // Check for standardized comments
        if (/\/\*\*[\s\S]*?\*\//g.test(content)) score += 0.2;
        
        // Check for repetitive patterns
        if (/(const|let|var)\s+\w+\s*=\s*[^;]+;/g.test(content)) score += 0.2;
        
        // Check for error handling patterns
        if (/try\s*{[\s\S]*?}\s*catch\s*\([\s\S]*?\)\s*{/g.test(content)) score += 0.2;
        
        // Check for type annotations
        if (/:\s*(string|number|boolean|any|void)\b/g.test(content)) score += 0.2;

        return score;
    }

    /**
     * Performs OpenAI-based code analysis with retry mechanism
     */
    private async performOpenAiAnalysis(content: string): Promise<number> {
        const operation = retry.operation({
            retries: 3,
            factor: 2,
            minTimeout: 1000,
            maxTimeout: 5000
        });

        return new Promise((resolve, reject) => {
            operation.attempt(async (currentAttempt) => {
                try {
                    const response = await this.openai.chat.completions.create({
                        model: "gpt-4",
                        messages: [{
                            role: "system",
                            content: "Analyze the following code and determine the likelihood it was AI-generated. Respond with a number between 0 and 1."
                        }, {
                            role: "user",
                            content: content
                        }],
                        temperature: 0.1,
                        max_tokens: 10
                    });

                    const score = parseFloat(response.choices[0].message.content);
                    resolve(isNaN(score) ? 0 : score);

                } catch (error) {
                    if (operation.retry(error)) {
                        this.logger.warn(`OpenAI analysis retry ${currentAttempt}`);
                        return;
                    }
                    this.logger.error(`OpenAI analysis failed: ${error.message}`);
                    resolve(0); // Fallback to zero score
                }
            });
        });
    }

    /**
     * Fallback detection method when primary methods fail
     */
    private async fallbackDetection(activity: IActivity): Promise<boolean> {
        try {
            const content = this.extractCodeContent(activity);
            if (!content) return false;

            const patternScore = await this.detectStandardPatterns(content);
            const heuristicScore = await this.performHeuristicAnalysis(content);
            
            const fallbackScore = (patternScore + heuristicScore) / 2;
            activity.metadata.aiConfidence = fallbackScore;
            
            return fallbackScore >= this.confidenceThreshold;

        } catch (error) {
            this.logger.error(`Fallback detection failed: ${error.message}`);
            return false;
        }
    }
}